{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-06-12T11:02:52.789Z","updated":"2019-08-02T02:17:12.000Z","comments":false,"path":"/404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-06-12T15:07:02.047Z","updated":"2020-06-12T15:07:02.047Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"一个95后大学生，最爱小袁，热爱编程，热爱民谣，足球，电影，最喜欢的球星NEYMAR…. 123456789101112131415161718192021&#123; about: &#123; name: \"王嘉伟\", age: 20, gender: \"男\", experience: \"0年\", address: \"重庆\", education: \"本科\", email: \"w714860761@163.com\", description: \"致力于JavaWeb、前端、python的学习, 以及前沿的思潮下进步\", &#125;, skills: [ [\"Html\", \"Javascript\", \"CSS\", \"ES6\"], [\"Git\"], [\"Vue.js\",\"Jquery\"], [\"ElementUI\", \"bootstrap\"], [\"Java\", \"Spring\", \"MyBatis\"], [\"Python\"], [\"Linux\"] ]&#125;"},{"title":"分类","date":"2020-06-12T11:55:26.991Z","updated":"2019-08-02T02:17:12.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-06-12T11:58:26.867Z","updated":"2019-08-02T02:17:12.000Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":""},{"title":"项目","date":"2020-06-12T11:27:23.769Z","updated":"2020-06-12T11:27:23.769Z","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-06-12T12:00:33.508Z","updated":"2019-08-02T02:17:12.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"使用gitee导入github项目，解决github下载速度缓慢","slug":"GithubSlow","date":"2020-06-13T16:00:00.000Z","updated":"2020-06-14T09:46:04.108Z","comments":true,"path":"2020/06/14/GithubSlow/","link":"","permalink":"http://yoursite.com/2020/06/14/GithubSlow/","excerpt":"","text":"使用gitee导入github项目，解决github下载速度缓慢的问题一、注册gitee账号: gitee官网：https://gitee.com/进入官网点击右上角注册账号 二、导入github项目: 点击右上角的加号：选择 从Github/GitLab导入仓库：输入github项目的仓库地址，然后下滑点击导入按钮即可：和github一样，打开仓库进行下载，这时候已经是国内的下载速度了 Finish","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"}]},{"title":"搭建个人博客(四)：上传Hexo博客至github","slug":"HexoFour","date":"2020-06-13T16:00:00.000Z","updated":"2020-06-14T09:45:53.669Z","comments":true,"path":"2020/06/14/HexoFour/","link":"","permalink":"http://yoursite.com/2020/06/14/HexoFour/","excerpt":"","text":"看了很多的Hexo博客上传至github都有出入，这里说下我的方式，上传成功的我觉得这个方法应该是最简单的，hhh 一、注册github账号 github官网：https://github.com/注册账号，github进不去或访问慢的的自行百度方法 二、新建仓库注意: 仓库的name必须是你的github用户名，这个后来就是你网站的域名，选择public完成上述操作后点击创建仓库 三、打开博客根目录下的_config.yml站点配置文件 进入github创建好的仓库中拿到仓库的URL打开配置文件进行如下配置: 12345678# 原配置文件的字段deploy: type: ''# 修改后deploy: type: git repo: # 你的github仓库的URL地址 branch: master 四、进行博客上传 在博客文件夹下打开git bash命令行窗口输入如下指令： 1hexo d # 部署博客 之后等待会提示输入github的账号和密码，输入后等待即可，完成后，在浏览器使用你的github用户名+github.io进行访问（这个是别人也可以访问到的地址哦！）例：wdadad.github.io 注意: 如果密码和账号输入错误不会有相关提示，会部署失败，可以使用Ctrl+C 组合快捷键退出后重新部署 Finish","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"搭建个人博客(三)：Hexo-theme-pure个人博客中博文上传以及分类和标签的设定","slug":"HexoThree","date":"2020-06-13T16:00:00.000Z","updated":"2020-06-14T09:45:32.332Z","comments":true,"path":"2020/06/14/HexoThree/","link":"","permalink":"http://yoursite.com/2020/06/14/HexoThree/","excerpt":"","text":"Hexo-theme-pure中博文的上传在Hexo中，添加博文可以通过在博客根目录 /source/_post 下新建MarkDown文档进行上传 1、打开 /source/_post 目录新建MarkDown文档，并在首行添加如下字段： 123456# 通过如下字段,Hexo会自动添加博文分类和博文标签的相关配置---title: title # 添加博文标题categories: categories # 添加博文分类tags: tags # 添加博文标签--- 如下图： 2、在博客文件夹下打开git bash命令行窗口依次使用如下指令： 123hexo cleanhexo ghexo s 启动服务后：进入本地浏览器输入:http://localhost:4000/，如下图:上传成功，博文分类和博文标签都添加成功！ Finish","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"搭建个人博客(二)：Hexo主题pure使用指南","slug":"HexoTwo","date":"2020-06-13T16:00:00.000Z","updated":"2020-06-14T09:45:17.794Z","comments":true,"path":"2020/06/14/HexoTwo/","link":"","permalink":"http://yoursite.com/2020/06/14/HexoTwo/","excerpt":"","text":"Hexo-theme-pures是一个Hexo的主题框架效果查看:溯的主页 一、使用pure主题pure主题地址:https://github.com/cofess/hexo-theme-pure.git themes/pure 在你的博客根目录下右击选择git bash here命令行窗口输入如下命令 1、克隆pure到本地：1git clone https://github.com/cofess/hexo-theme-pure.git themes/pure 注意:如果github下载慢，建议使用gitee导入pure的girthub仓库，然后进行下载，具体操作请查看：使用gitee导入github项目，解决github下载速度缓慢如果使用gitee下载，请解压至博客文件夹下的themes目录下下载后 如下图: 2、启用pure主题:配置文件说明:在 Hexo 中主要有两份配置文件，其名称都是 _config.yml。 一份位于博客根目录下，主要包含 Hexo 本身的配置；另一份位于主题根目录下，主要用于配置主题相关的选项。（1）打开博客配置文件_config.yml，做如下修改: 12language: zh-CN //设置主题为中文版，若使用英文版则不修改theme: hexo-theme-pure //修改hexo主题 （2）在博客文件夹下打开git bash命令行窗口依次使用如下指令: 12hexo cleanhexo s 启动服务后：进入本地浏览器输入:http://localhost:4000/，如下图 3、安装pure插件:在博客文件夹下打开git bash命令行窗口依次使用如下指令： 12345npm install hexo-wordcount --savenpm install hexo-generator-json-content --savenpm install hexo-generator-feed --savenpm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 二、配置pure主题1、主题的基本配置：将主题目录中 /theme/_source/ 下的所有东西复制进博客根目录的source文件夹中注意: 看清楚是哪个目录 2、个人信息的配置：打开主题根目录下的_config.yml配置文件： （1）配置站点左边的主目录: 1234567891011# menumenu: Home: . Archives: archives # 归档 # categories指代博客根目录的source下的categories文件夹,可进行相关配置,下同 Categories: categories # 分类 Tags: tags # 标签 Repository: repository # github repositories Books: books # 豆瓣书单 Links: links # 友链 About: about # 关于 单个目录界面的相关配置可在博客根目录的source下的同名文件夹中进行配置 （2）配置站点标题: 1234567891011# Sitesite: logo: enabled: true width: 40 height: 40 url: ../images/logo.png title: Hexo # 页面title favicon: /favicon.png # 页面icon board: &lt;p&gt;欢迎交流与分享经验!&lt;/p&gt; # 站点公告 copyright: false # 底部版权信息,使用true开启 （3）配置打赏信息: 1234567891011# Donatedonate: enable: true # 微信打赏 wechatpay: qrcode: images/donate/wechatpayimg.png # 在主题目录的source文件夹中进行图片的设定 title: 微信支付 # 支付宝打赏 alipay: qrcode: images/donate/alipayimg.png # 在主题目录的source文件夹中进行图片的设定 title: 支付宝 （4）配置个人信息: 123456789101112131415161718192021# profileprofile: enabled: true # 是否展示个人信息 avatar: images/avatar.jpg # 在主题目录的source文件夹中进行图片的设定 gravatar: # Gravatar email address, if you enable Gravatar, your avatar config will be overriden author: 昵称 author_title: Web Developer &amp; Designer author_description: 个人简介。 location: Shenzhen, China follow: https://github.com/cofess # Social Links social: links: # 左边目录底部的链接配置，可自行删减 github: https://github.com/cofess weibo: http://weibo.com/cofess twitter: https://twitter.com/iwebued # facebook: / # dribbble: / behance: https://www.behance.net/cofess rss: atom.xml link_tooltip: true # enable the social link tooltip, options: true, false （5）配置about界面右栏目中的信息: 12345678910111213141516171819202122232425262728# My Skills skills: Git: ★★★☆☆ Gulp: ★★★☆☆ Javascript: ★★★☆☆ HTML+CSS: ★★★☆☆ Bootstrap: ★★★☆☆ ThinkPHP: ★★★☆☆ 平面设计: ★★★☆☆# My Personal Linkslinks: Github: https://github.com/cofess Blog: http://blog.cofess.com 微博: http://weibo.com/cofess 花瓣: http://huaban.com/cofess Behance: https://www.behance.net/cofess# My Personal Labelslabels: - 前端 - 前端开发 - 前端重构 - Web前端 - 网页重构# My Personal Worksworks: name: link: http://www.example.com date: 2016 （6）开启评论功能: 12comment: type: valine # 启用哪种评论系统 Valine一个无后端的评论框工具，其依赖于 Leancloud 开发，所以使用前需要先注册 Leancloud 账号Valine配置 12345678910111213valine: # Valine官方地址: https://valine.js.org appid: # 你的 leancloud 应用 appid appkey: # 你的 leancloud 应用 appkey notify: true # 是否开始评论邮件提醒, 教程: https://github.com/xCss/Valine/wiki verify: false # 是否开始验证码功能, 开始邮件提醒会自动开启验证码功能 placeholder: 说点什么... # 输入框默认内容 avatar: mm # 头像展示方式, 具体设置项教程: https://valine.js.org/configuration.html#avatar meta: nick,mail,link # 自定义评论信息 pageSize: 10 # 评论列表分页 lang: zh-cn, # 多语言支持 zh-cn | en visitor: true # 文章阅读量统计: https://valine.js.org/visitor.html highlight: true # 代码高亮 recordIP: true # 记录评论者的IP （7）开启搜索功能: 1234# Searchsearch: insight: true # 内置搜索功能, baidu: false # 百度搜索功能,不可以同时使用 （8）展示github项目: 123# Githubgithub: username: cofess # github用户名 （9）开启文章字数，阅读时长，浏览量统计: 1234567891011121314# PVpv: # 浏览量统计 busuanzi: enable: false # 不蒜子统计，一般使用不蒜子统计，使用true开启 leancloud: enable: false # leancloud统计 app_id: # leancloud &lt;AppID&gt; app_key: # leancloud &lt;AppKey&gt; # wordcountpostCount: enable: false wordcount: true # 文章字数统计 min2read: true # 阅读时长预计 （10）友情链接的配置: 选择博客根目录下 /source/_data/ 中的links.yml配置文件，可仿照其中样例进行配置 （11）分类和标签的配置: 三、更新站点，查看效果在博客文件夹下打开git bash命令行窗口依次使用如下指令： 123hexo cleanhexo ghexo s 启动服务后：进入本地浏览器输入:http://localhost:4000/ 进行查看 记得当初思考怎么配置分类和标签时候，纠结了很久，反复的看配置文件，最后发现分类和标签的配置需在博文中设置，在下一节讲解：下一节 Finish","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"搭建个人博客(一)：Hexo本地的使用和配置","slug":"HexoOne","date":"2020-06-12T16:00:00.000Z","updated":"2020-06-14T09:45:45.041Z","comments":true,"path":"2020/06/13/HexoOne/","link":"","permalink":"http://yoursite.com/2020/06/13/HexoOne/","excerpt":"","text":"最近突然想搭建自己的个人博客，刚完成，准备吧过程分享给大家，包括主题的修改等，废话不多说了 上效果:溯 一、准备工作1. 了解HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 2. git版本控制工具Git是一个免费的、开源的版本控制软件。在Windows上安装git，一般为msysgit，官方下载地址 :http://code.google.com/p/msysgit/downloads/list安装步骤下一步即可…… 3. Node.js环境简单的说 Node.js 就是运行在服务端的 JavaScript。nodejs官网：https://nodejs.org/en/注意:选择LTS版本安装，直接全部点击下一步就行 二、配置环境变量配置好环境变量后（默认大家都不是新手了哈，如果还是不知道，百度…）打开cmd输入 node -v (检查版本)输入npm -v (检查版本）输入 git –version （检查git版本，目的是为了看有没有安装成功git） 如上表示环境变量配置成功 三、本地配置Hexo环境常用hexo命令: 123456hexo init //初始化hexo博客hexo clean //清除缓存 网页正常情况下可以忽略此条命令hexo g //生成静态网页hexo d //开始部署hexo s //启动本地服务器npm install -g hexo-cli //hexo的安装 在你的目录下建立文件夹(建议取名blog，必须为空)，右键选择git bash here打开git，如下图: 在打开的终端窗口中输入“npm install -g hexo-cli”来进行hexo的安装，安装成功后如下图: 继续输入”hexo init”进行博客初始化，从github地址克隆项目，成功后如下图，多等一会: 之后分别键入”hexo g”和”hexo s”，如下图 至此，进入本地浏览器输入:http://localhost:4000/就可以查看博客了，如下 激动人心！Ctrl+C:停止服务器下一节讲解配置hexo的主题，让你的博客更加的美观","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"对Spring的JDBC框架再封装——提高效率","slug":"SpringJDBCSecondaryPackaging","date":"2020-05-31T16:00:00.000Z","updated":"2020-06-14T09:43:02.777Z","comments":true,"path":"2020/06/01/SpringJDBCSecondaryPackaging/","link":"","permalink":"http://yoursite.com/2020/06/01/SpringJDBCSecondaryPackaging/","excerpt":"","text":"一、问题描述问题描述:在CRUD的项目中使用JdbcTemplate操作数据库时,在dao层我们会发现这样一个问题，代码量重复且繁杂，现在如下类型参照表:在对他进行操作时，会有以下的代码: 1.实体类(model层) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * 损坏类型子参照表 */@Componentpublic class Damage_type_stable &#123; private int damage_type_sid;//损坏类型子编号 private String damage_type_sname;//损害类型名称 private String damage_type_shape;//损坏形状 private String damage_type_calcu;//计算方法 private int damage_type_fid;//损坏类型父编号 public int getDamage_type_sid() &#123; return damage_type_sid; &#125; public void setDamage_type_sid(int damage_type_sid) &#123; this.damage_type_sid = damage_type_sid; &#125; public String getDamage_type_sname() &#123; return damage_type_sname; &#125; public void setDamage_type_sname(String damage_type_sname) &#123; this.damage_type_sname = damage_type_sname; &#125; public String getDamage_type_shape() &#123; return damage_type_shape; &#125; public void setDamage_type_shape(String damage_type_shape) &#123; this.damage_type_shape = damage_type_shape; &#125; public String getDamage_type_calcu() &#123; return damage_type_calcu; &#125; public void setDamage_type_calcu(String damage_type_calcu) &#123; this.damage_type_calcu = damage_type_calcu; &#125; public int getDamage_type_fid() &#123; return damage_type_fid; &#125; public void setDamage_type_fid(int damage_type_fid) &#123; this.damage_type_fid = damage_type_fid; &#125; @Override public String toString() &#123; return \"Damage_type_stable&#123;\" + \"damage_type_sid=\" + damage_type_sid + \", damage_type_sname='\" + damage_type_sname + '\\'' + \", damage_type_shape='\" + damage_type_shape + '\\'' + \", damage_type_calcu='\" + damage_type_calcu + '\\'' + \", damage_type_fid=\" + damage_type_fid + '&#125;'; &#125;&#125; 2、持久化层(dao层) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253** * 损坏类型子参照表数据库操作:持久化层 */@Repositorypublic class DamageTypeStableDao &#123; @Autowired private JdbcTemplate jdbcTemplate; /** * 查看所有损坏子类型信息 * @return 返回Damage_type_stable对象的List集合 */ public List&lt;Damage_type_stable&gt; findAll()&#123; try &#123; String sql=\"\"; List&lt;Damage_type_stable&gt; query = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;Damage_type_stable&gt;(Damage_type_stable.class)); return query; &#125; catch (DataAccessException e) &#123; e.printStackTrace(); return null; &#125; &#125; /** * 添加损坏子类型信息 * @param damage_type_stable 损坏子类型类 */ public void add(Damage_type_stable damage_type_stable)&#123; String sql=\"\"; jdbcTemplate.update(sql,damage_type_stable.getDamage_type_sid(),damage_type_stable.getDamage_type_sname(),damage_type_stable.getDamage_type_shape(),damage_type_stable.getDamage_type_calcu(),damage_type_stable.getDamage_type_fid()); &#125; /** * 删除损坏子类型信息 * @param id 损坏子类型对应编号 * @throws Exception 删除产生的依赖异常 */ public void delete(int id)throws DataAccessException&#123; String sql=\"\"; jdbcTemplate.update(sql,id); &#125; /** * 修改损坏子类型信息 * @param damage_type_stable 损坏子类型类 */ public void change(Damage_type_stable damage_type_stable)&#123; String sql=\"\"; jdbcTemplate.update(sql,damage_type_stable.getDamage_type_sname(),damage_type_stable.getDamage_type_shape(),damage_type_stable.getDamage_type_calcu(),damage_type_stable.getDamage_type_fid(),damage_type_stable.getDamage_type_sid()); &#125;&#125; 我们会很容易的发现,在使用JdbcTemplate的update和query方法进行自动封装时对可变参数的传入重复且繁杂,假如我们的实体类有几十,甚至几百个属性呢….. 二、解决办法解决思路（以add方法为例）:在JdbcTemplate中，提供了update方法的另一种重载方式:update(sql,Object []);，可以传入一个Object类的数组，按顺序依次封装。既然如此，我们就可以通过Java的反射机制，写一个工具方法，以Object类对象为参数，通过获取到对象中的所有get方法，将get到的返回值封装在一个数组里，使用上述update(sql,Object []);，进行数据库操作。实现自动封装update方法的可变参数。 1、建库,并编写实体类(以Users类为示例） 12345678910111213141516171819202122232425262728293031323334/** * 用户实体类 */@Componentpublic class Users &#123; private String username;//用户名 private String pasword;//密码 public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPasword() &#123; return pasword; &#125; public void setPasword(String pasword) &#123; this.pasword = pasword; &#125; @Override public String toString() &#123; return \"Users&#123;\" + \"username='\" + username + '\\'' + \", pasword='\" + pasword + '\\'' + '&#125;'; &#125;&#125; 2、获取到类对象所有的get方法 1234567891011121314151617181920212223 /** * 获取object的所有get方法 * @return */public List&lt;Method&gt; getAllReadMethod(Object object)&#123; List&lt;Method&gt; method=new ArrayList&lt;Method&gt;(); Class&lt;? extends Object&gt; testClass = object.getClass(); //获得属性 Field[] fields = object.getClass().getDeclaredFields(); for (Field field : fields) &#123; try &#123; PropertyDescriptor pd = new PropertyDescriptor(field.getName(), testClass); //获得get方法 Method getMethod = pd.getReadMethod(); //添加进List集合 method.add(getMethod); &#125; catch (IntrospectionException e) &#123; e.printStackTrace(); &#125; &#125; return method;&#125; 3、得到所有get方法的返回值，并封装进Object数组中，然后返回 123456789101112131415161718192021222324 /** * 得到所有get方法的返回值 * @return */public Object[] getAllMethodName(Object object)&#123; //调用第一步中的方法:获取到所有的get方法 List&lt;Method&gt; allReadMethod = getAllReadMethod(object); Object [] values=new Object[allReadMethod.size()]; int i=0; for(Method e:allReadMethod)&#123; try &#123; Object invoke = e.invoke(object); String s = invoke.toString(); values[i]=s; i++; &#125; catch (IllegalAccessException e1) &#123; e1.printStackTrace(); &#125; catch (InvocationTargetException e1) &#123; e1.printStackTrace(); &#125; &#125; return values;&#125; 4、编写add方法 12345678910/** * 添加信息 * @param sql * @param object */ public void add(String sql,Object object) &#123; Object[] allMethodName = getAllMethodName(object); jdbcTemplate.update(sql,allMethodName); &#125; 5、测试 123456789@Test public void test04()&#123; Users user = new Users(); user.setUsername(\"abcde\"); user.setPasword(\"12345\"); UserDao bean = ioc.getBean(UserDao.class); bean.add(user); &#125; 6、测试结果附完整代码(add,delete,change,findAll方法): ClassUtils.java： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183@Componentpublic class ClassUtils &#123; @Autowired private JdbcTemplate jdbcTemplate; /** * 获取object的所有get方法 * @return */ public List&lt;Method&gt; getAllReadMethod(Object object)&#123; List&lt;Method&gt; method=new ArrayList&lt;Method&gt;(); Class&lt;? extends Object&gt; testClass = object.getClass(); //获得属性 Field[] fields = object.getClass().getDeclaredFields(); for (Field field : fields) &#123; try &#123; PropertyDescriptor pd = new PropertyDescriptor(field.getName(), testClass); //获得get方法 Method getMethod = pd.getReadMethod(); method.add(getMethod); &#125; catch (IntrospectionException e) &#123; e.printStackTrace(); &#125; &#125; return method; &#125; /** * 得到所有get方法的返回值 * @return */ public Object[] getAllMethodName(Object object)&#123; List&lt;Method&gt; allReadMethod = getAllReadMethod(object); Object [] values=new Object[allReadMethod.size()]; int i=0; for(Method e:allReadMethod)&#123; try &#123; Object invoke = e.invoke(object); String s = invoke.toString();// System.out.println(s); values[i]=s; i++; &#125; catch (IllegalAccessException e1) &#123; e1.printStackTrace(); &#125; catch (InvocationTargetException e1) &#123; e1.printStackTrace(); &#125; &#125; return values; &#125; public Object[] getAllMethodNameAdd(Object object)&#123; List&lt;Method&gt; allReadMethod = getAllReadMethod(object); Object [] values=new Object[allReadMethod.size()-1]; int j=0; for(int i=1;i&lt;allReadMethod.size();i++)&#123; try &#123; Object invoke = allReadMethod.get(i).invoke(object); String s = invoke.toString(); //System.out.println(s); values[j]=s; j++; &#125; catch (IllegalAccessException e1) &#123; e1.printStackTrace(); &#125; catch (InvocationTargetException e1) &#123; e1.printStackTrace(); &#125; &#125; return values; &#125; /** * 得到类中每个参数的类型 * @param object */// public void getAllMethodType(Object object)&#123;// List&lt;Method&gt; allReadMethod = getAllReadMethod(object);// int i=0;// int[] values=new int[allReadMethod.size()];// for (Method e:allReadMethod)&#123;// Type type = e.getAnnotatedReturnType().getType();// i++;// System.out.println(type);// &#125;//// &#125; /** * 模板:浏览信息 * @param sql:sql语句 * @param object :类名称 * @return */ public List&lt;?&gt; findAll(String sql,Object object)&#123; try &#123; List&lt;?&gt; query = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(object.getClass())); return query; &#125; catch (DataAccessException e) &#123; e.printStackTrace(); return null; &#125; &#125; /** * 模板:添加信息 * @param sql * @param object */ public void add(String sql,Object object) &#123; Object[] allMethodName = getAllMethodNameAdd(object); jdbcTemplate.update(sql,allMethodName); &#125; /** * 模板:删除信息 * @param sql:sql语句 * @param id:id */ public void delete(String sql,int id)&#123; jdbcTemplate.update(sql,id); &#125; //测试 public void delete(String sql,String id)&#123; jdbcTemplate.update(sql,id); &#125; /** * 模板:修改信息 * @param sql * @param object */ public void change(String sql,Object object)&#123; Object[] allMethodName = getAllMethodName(object); Object o=allMethodName[0]; for(int i=0;i&lt;allMethodName.length-1;i++)&#123; allMethodName[i]=allMethodName[i+1]; &#125; allMethodName[allMethodName.length-1]=o; //System.out.println(allMethodName.length); jdbcTemplate.update(sql,allMethodName); &#125; /** * 模板:信息回显 * @param sql * @param id 用户名称:String * @return */ public Object messageBackLook(String sql,int id,Object object)&#123; try &#123; Object o = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;&gt;(object.getClass()), id); return o; &#125; catch (DataAccessException e) &#123; e.printStackTrace(); return null; &#125; &#125; /** * 信息回显 * @param sql * @param id 用户id:int * @return */ public Object messageBackLook(String sql,String id,Object object)&#123; try &#123; Object o = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;&gt;(object.getClass()), id);// System.out.println(o); return o; &#125; catch (DataAccessException e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; finish！","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring配置:自动扫描","slug":"SpringAutomaticScanning","date":"2020-05-21T16:00:00.000Z","updated":"2020-06-14T09:43:29.683Z","comments":true,"path":"2020/05/22/SpringAutomaticScanning/","link":"","permalink":"http://yoursite.com/2020/05/22/SpringAutomaticScanning/","excerpt":"","text":"Spring配置:自动扫描一、在Spring的配置文件applicationContext.xml头部,引入context命名空间:xmlns:context=”http://www.springframework.org/schema/context&quot;xsi:schemaLocation=”http://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd&quot; 二、在配置文件中添加配置扫描所在包下(下图中为扫描com包)所有注解: &lt;context:component-scan base-package=”com”/&gt; 如下图:至此,配置成功!","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"JavaSE学习笔记(四):String类","slug":"JavaSEStudyFour","date":"2020-04-14T16:00:00.000Z","updated":"2020-06-14T09:44:24.832Z","comments":true,"path":"2020/04/15/JavaSEStudyFour/","link":"","permalink":"http://yoursite.com/2020/04/15/JavaSEStudyFour/","excerpt":"","text":"String类String类提供程序中指定字符串的一系列方法，是不可修改字符序列(即无法执行对字符串本身的修改)，下面对字符串的定义及常用方法进行解释。1、字符串的定义字符串定义格式:String 字符串名称=”字符串内容”;String 字符串名称=new String(“字符串内容”); 123//例:String str=\"我爱JAVA\";String str=new String(\"我爱JAVA\"); 2、获取字符串长度方法：int length()，返回一个正整数 1234//例:String str=\"abcdefg\";System.out.println(str.length());//输出:7 3、获取指定索引位置字符(1) 获取指定字符(返回char型数据)：char charAt(int index);//获取索引位置字符串(2) 获取字符串位置(都返回int型数据)：int indexOf(String str);//获取第一次出现的索引int indexOf(String str,int formIndex);//从指定位置往后查int lastIndexOf(String str);//获取最后一次出现的位置int lastIndexOf(String str,int formIndex);//从指定位置往前查 12345678910111213//例:String str=\"abcdefgabc\";//获取字符串的第一个字符System.out.println(str.charAt(0));//获取第一次出现的索引位置System.out.println(str.indexOf(\"abc\"));//获取第一次出现的索引位置，从指定位置往后查System.out.println(str.indexOf(\"abc\",4));//获取最后一次出现的索引位置System.out.println(str.lastIndexOf(\"abc\"));//获取最后一次出现的索引位置，从指定位置往前查System.out.println(str.lastIndexOf(\"abc\",6));//分别输出:a|0|7|7|0 4、截取字符串下列方法返回值都为字符串类型(String类型)：(1) 指定开始位置截取字符串String substring(int beginIndex);//beginIndex为开始位置(1) 指定开始的位置和结束的位置截取字符串String substring(int beginIndex,int endIndex);//beginIndex为开始位置，endIndex为结束位置 1234567//例:String str=\"abcdefg\";//指定开始位置截取字符串System.out.println(str.substring(3));//指定开始的位置和结束的位置截取字符串System.out.println(str.substring(1,4));//分别输出:defg|bcd 5、拼接字符串使用‘+’运算符可实现多个字符串的拼接 1234//例:String str=\"abc\"+\"123\"; System.out.println(str);//输出:abc123 6、判断字符串的开始与结尾(1) 判断字符串结尾内容(返回一个布尔型数据)：boolean endsWith(String suffix);// suffix为要对比的字符串(2) 判断字符串句首内容(返回一个布尔型数据)：boolean startsWith(stirng prefix);//prefix为要对比的字符串 123456789//例:String str=\"123abc123\"; //如果传入的字符串123是字符串a的结尾内容,则返回true，否则返回falseSystem.out.println(str.endsWith(\"123\"));System.out.println(str.endsWith(\"1234\"));//如果传入的字符串123是字符串a的开头内容,则返回true，否则返回falseSystem.out.println(str.startsWith(\"123\"));System.out.println(str.startsWith(\"1234\"));//输出:true|false|true|false 7、判断字符串是否相等Java中规定不能直接使用”==”号进行字符串内容的比较，应使用如下方法(1) 字符串不忽略大小写的比较(返回一个布尔型数据)：boolean equals(String antherString);(2) 字符串忽略大小写的比较(返回一个布尔型数据)：boolean equalsIgnoreCase(String anotherString); 123456789//例:String str=\"abc\"; //如果字符串相等(不忽略大小写),则返回true，否则返回falseSystem.out.println(str.equals(\"abc\"));System.out.println(str.equals(\"Abc\"));//如果字符串相等(忽略大小写),则返回true，否则返回falseSystem.out.println(str.equalsIgnoreCase(\"abc\"));System.out.println(str.equalsIgnoreCase(\"Abc\"));//输出:true|false|true|true 8、字符串替换下列方法返回值都为字符串类型(String类型)：(1) 方法一：String repalce(Strinh target,String replacement);//target为旧字符序列，repalcement为替换后的新字符序列(2) 方法二：String relpaceAll(String regex, String replacement)；//regex表示一种格式，将String中符合regex所给格式的字符串替换成replacement(3) 方法三：String replaceFirst(String regex, String replacement); //将String中符合regex所给格式的第一个字符替换成replacement 1234567//例:String str=\"www.baidu.com\"; //字符串替换System.out.println(str.replace(\".\",\"#\"));System.out.println(str.replaceAll(\".\",\"#\"));System.out.println(str.replaceFirst(\".\",\"#\"));//输出:www#baidu#com|#############|#ww.baidu.com 9、字符串分割下列方法返回值都为字符串类型(String类型)的数组：(1) 字符串分割：String[] split(String regex);//regex用于规定分割符号(2) 限制分割次数：String[] split(String regex,int limit);//regex用于规定分割符号，limit为分割次数 12345678910111213//例:String str=\"abc.def.123\"; //字符串分割String[] strArray=str.split(\"\\\\.\");for(String s:strArray) &#123; System.out.print(s+\" \");&#125;//限制字符串分割次数String[] strArray1=str.split(\"\\\\.\",2);for(String s:strArray1) &#123; System.out.print(s+\" \");&#125;//输出:abc def 123|abc def.123 10、字符串大小写转换下列方法返回值都为字符串类型(String类型)：(1) 字符串内字符全部变成大写：String toUpperCase();(2) 字符串内字符全部变成小写：String toLowerCase(); 1234567//例:String str=\"abc DEF\";//字符串内字符全部变成大写System.out.println(str.toUpperCase());//字符串内字符全部变成小写System.out.println(str.toLowerCase());//输出:ABC DEF|abc def 11、格式化字符串String.format(String format,Object…args); 123456//例:Date date = new Date(); //格式化字符串String str=String.format(\"%tF\",date);System.out.println(str);//输出:2020-04-15 12、去除空白内容下列方法返回值都为字符串类型(String类型)：(1) 去除首位空白内容：String trim();(2) 去除字符串中所有空白内容使用上文中的replaceAll方法String replaceAll(“\\s”,””);// \\ s正则表达式代表空白内容 ‘’”为空内容字符串 12345678//例:String str=\" abc\";String str1=\" abc 1 2 3\";System.out.println(str);System.out.println(str.trim());System.out.println(str1);System.out.println(str1.replaceAll(\"\\\\s\",\"\"));//输出: abc|abc| abc 1 2 3|abc123","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"JavaSE学习笔记(三):基本数据类型","slug":"JavaSEStudyThree","date":"2020-04-12T16:00:00.000Z","updated":"2020-06-14T09:44:00.703Z","comments":true,"path":"2020/04/13/JavaSEStudyThree/","link":"","permalink":"http://yoursite.com/2020/04/13/JavaSEStudyThree/","excerpt":"","text":"基本数据类型在程序设计中经常用到一系列类型，它们需要特殊对待。可以把它们想象成“基本”类型。之所以特殊对待，是因为对于特别小的、简单的变量，往往用new来创建对象不是很有效的。因此，对于这些类型，Java采取与C和C++相同的方法，可以不用new来创建对象，例如：int a=15。一、整数: byte:表示整数，最小的整数类型，包装器为Byte short:也表示整数，但是表示范围更大，占两个字节(一字节=8-bit)，包装器为Short int:常用的整数表达类型，占4个字节，包装器为Integer long:最大的整数类型，占8个字节，包装器为Long 二、浮点数: float:表示浮点数(小数)类型，占4个字节，包装器为Float double:可以表示最大的浮点数类型，占8个字节，包装器为Double 三、字符: char:字符表示类型，一个char可以存储一个字符，占2字节，包装器为Character 四、布尔类型: boolean类型所占存储空间的大小没有明确指定，仅定义为能够取字面值true或false，包装器为Boolean 五、数据类型：void: Java语言是强类型（Strong typed）的，从方法申明的语法可以看出方法的定义必须有返回值，而void就是空，在方法申明的时候表示该方法没有返回值。在此，你只需要知道，void是空类型","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"JavaSE学习笔记(二):命令行编译简单的Java程序：Hello World","slug":"JavaSEStudyTwo","date":"2020-04-02T16:00:00.000Z","updated":"2020-06-14T09:43:49.017Z","comments":true,"path":"2020/04/03/JavaSEStudyTwo/","link":"","permalink":"http://yoursite.com/2020/04/03/JavaSEStudyTwo/","excerpt":"","text":"Java程序编译过程Java的编译过程分为4步:1、java源代码文件的后缀名是”.java”的形式，通过编译器(compiler)被编译成字节码文件(“.class”后缀的文件)2、不论是在什么系统中，java的字节码文件都是”.class”后缀的，这也是java可以跨平台的原因。3、针对不同的平台，通过不同的解释器(interpreter)，去解释运行编译后的字节码文件。4、最终，我们就看到了程序运行的结果。最终过程：源文件-&gt;编译器-&gt;字节码文件-&gt;解释器-&gt;运行结果 Java语法的初步认识1、在Java源文件中，类名必须和文件名相同。2、在Java中,类的定义形式为：public Class 类名{};3、学过C语言的同学都知道(建议学Java之前对C或C++进行基本的学习)，C语言中有一个主函数(main)，是程序的入口，在Java中同样也有这样一个函数(C语言中的函数就是Java中的方法，下文中以方法代替)，格式如下:public static void main(String[] args){}。注意:方法必须写在类中！4、在Java中字符串使用双引号来表示。例：”Hello World!”。5、Java中的输出函数使用：System.out.println();。 编译运行简单的Java程序：输出Hello World1、在任意路径新建记事本，输入如下图中的内容(文件中的的符号必须全是英文符号)：2、如下图，修改记事本的名称为HelloWorld(类名)，并修改后缀为：.java3、使用Win+R组合键打开命令行窗口，输入 “ cd+你的java文件路径 “后回车(路径必须是英文路径)，如下图：4、以E盘为例，输入：” E: “，回车(如果文件在D盘，则输入：” D: “)，如下图5、使用 javac 命令(编译命令)编译java源文件：” javac HelloWorld.java”(必须带入后缀名)，如下图:6、打开文件路径会发现目录下出现了一个以” .class “为后缀的文件，这就是字节码文件，如下图：7、使用 java 命令(运行命令)运行字节码文件：” java HelloWorld “(不需要带入后缀名)，输出Hello World，如下图：注意：如果CLASSPATH环境变量没有配置正确，则会报错。至此，java程序运行成功！","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"JavaSE学习笔记(一):Java语言概述及jdk环境搭建","slug":"JavaSEStudyOne","date":"2020-04-01T16:00:00.000Z","updated":"2020-06-14T09:44:14.573Z","comments":true,"path":"2020/04/02/JavaSEStudyOne/","link":"","permalink":"http://yoursite.com/2020/04/02/JavaSEStudyOne/","excerpt":"","text":"Java语言概述1.什么是Java(百度百科)Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 ，同时Java还是一门解释性语言。在这里你只需要知道：Java是一门解释性编程语言，是面向对象的。其他知识我们会在后续学习中进行补充，下面就让我们开始探索Java的世界吧。 jdk下载1.jdk是什么:java development kit java开发工具包，下载安装配置环境后就可以使用Java语言了2.jdk官网下载地址:https://www.oracle.com/java/technologies/javase-downloads.html打开链接看到下图界面3.下滑界面后找到Java SE 8u241(推荐安装jdk8的版本,更加稳定)目录并点击Oracle JDK下的JDK Download，如下图4.点击后进入如下界面5.下滑找到windows x64(这里说的是windows64位的系统,其他系统可以自己找到相对应的jdk进行安装)后的jdk安装包进行下载，如下图6.点击后会出现如下界面,接受相关协议并进行点击下载,可能会出现相关登录提示,进行注册和登录后即可下载(如果觉得下载速度慢或者操作繁琐可以通过百度的资源进行直接下载)7.下载好后双击进入安装界面，如下图下图标记处可以更改安装路径这里显示安装成功！ jdk环境变量配置配置环境变量的目的:java-home的配置提供JDK的安装目录，path的配置提供的是java的编译环境，classpath的配置提供的是java的运行环境。1、打开此电脑(即我的电脑),进入如下界面，找到左侧栏中此电脑，鼠标右击选择属性2、进入如下界面,点击左侧的高级系统设置3、进入如下界面点击环境变量4、点击图中箭头所指的新建按钮5、变量名中填写JAVA_HOME(代表jdk的位置)，之后在变量值中填入jdk的安装路径，点击确定6、再新建一个CLASSPATH变量,变量值为：%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar;（注意最后有一个分号,如果没有分号,class文件会无法运行）7、之后找到名为Path的变量(如图)，双击8、点击新建9、如图：填入：%JAVA_HOME%\\bin(注意,必须是写在bin目录下)，点击确定确定确定就ok啦如上环境变量配置完成！ jdk环境变量配置测试1、使用Win+R组合快捷键,打开命令行窗口,如下图2、输入java -version,显示如下图信息表示正常3、输入javac,显示如下图信息表示正常4、输入java,显示如下图信息表示正常如上,环境变量配置成功！ 至此为止,jdk的下载安装以及环境变量的配置就完成了！ 下一节:命令行编译简单的java程序！","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"一个可视化的java程序解析XML文档（存储学生信息数据）","slug":"XmlAnalysis","date":"2020-02-14T16:00:00.000Z","updated":"2020-06-14T09:41:57.294Z","comments":true,"path":"2020/02/15/XmlAnalysis/","link":"","permalink":"http://yoursite.com/2020/02/15/XmlAnalysis/","excerpt":"","text":"一、XML文档解析基础概念1、XML文档有四种解析方法：（1）Dom文档对象解析（2）SAX简单的XML API（3）JDOM Java文档对象模型（常用）（4）DOM4J扩展与JDOM（常用）本文主要讲解最后一种解析方法： 2、Dom4j解析XML文档dom4j是由第三方提供扩展子JDOMAPI的一组解析XML文件的java实现，它只和java有关。dom4j对XML文档实现与JDOM类似，idom将XML文档中的每个节点（node）称之为Element(元素)，并提供对元素上下级的获取等实用方法。dom4j解析XML大体分为两种操作：（1）读取目标XML文档并解析，封装成运行时的Java对象进行处理（2）将运行时Java对象以XML文件方式写入硬盘存储 **3、Dom4j写入XML文档步骤：**（1）创建DocumentFactory用来创建Document对象（2）使用DOM4J实现对Document对象操作（3）创建XMLWriter用来将Document对象写入XML文件（4）关闭相关文件流 4、Dom4j读取XML文档步骤：（1）基于xml文件路径创建File对象（2）创建SAXReader用来加载xml文件为Document（3）利用DOM4J相关方法解析XML文档（4）封装文档对象数据为Java对象 二、程序实例下面通过一个实例进行学习：实例概要：由XML文档存储学生数据，并对其数据进行增删改查的操作 学生类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.entity;/** * 学生类 * @author NEYMAR * */public class Student &#123; private String code;//学号 private String name;//姓名 private String sex;//性别 private String specialty;//专业 /** * 无参构造函数 */ public Student() &#123; ; &#125; /** * 含参构造函数 * @param code 学号 * @param name 姓名 * @param sex 性别 * @param specialty 专业 */ public Student(String code,String name,String sex,String specialty) &#123; this.code=code; this.name=name; this.sex=sex; this.specialty=specialty; &#125; public String getCode() &#123; return code; &#125; public void setCode(String code) &#123; this.code = code; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getSpecialty() &#123; return specialty; &#125; public void setSpecialty(String specialty) &#123; this.specialty = specialty; &#125;&#125; 工具类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.util;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStreamWriter;import java.io.Writer;import java.util.List;import org.dom4j.Document;import org.dom4j.io.OutputFormat;import org.dom4j.io.XMLWriter;import com.entity.Student;/** * 工具类 * @author NEYMAR * */public class Tools &#123; /** * 获取当前项目路径 * @return 返回该路径 */ public static String getprojectPath() &#123; String Path=System.getProperty(\"user.dir\"); return Path; &#125; /** * 获取类路径 * @return 返回该路径 */ public static String getClassPath() &#123; String Path=Tools.class.getClassLoader().getResource(\"\").getPath().toString(); return Path; &#125; /** * 判断学生对象是否为空 * @param e 学生对象 * @return 若为空，则返回true,若不为空，则返回false */ public static boolean isListEmpty(Student e) &#123; if(e==null) return true; return false; &#125; /** * 判断XML文件是否存在 * @param Path 路径 * @return 若存在，则返回true，否则返回false */ public static boolean isXmlEmpty(String name) &#123; String classPath=Tools.getClassPath();//获取类路径 File file=new File(classPath+\"com/Xml/\"+name); if(file.exists()) return true; return false; &#125;&#125; 实现解析XML文档数据的类（核心）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278package com.util;import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.io.Reader;import java.io.Writer;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.DocumentFactory;import org.dom4j.Element;import org.dom4j.io.OutputFormat;import org.dom4j.io.SAXReader;import org.dom4j.io.XMLWriter;import com.entity.Student;/** * 用Dom4j方式解析XML文档 * @author NEYMAR * */public class Dom4jManger &#123; //用DocumentFactory的静态方法创建DocumentFactory对象 public static DocumentFactory docfactory=DocumentFactory.getInstance(); /** * 初始化XML文档 * @param fileName 文件名 */ public Dom4jManger(String fileName,Student stu) &#123; Document doc=docfactory.createDocument(\"utf-8\");//创建document实例，并规定其编码格式为UTF-8 Element rootEle=docfactory.createElement(\"Students\");//创建文档根元素 doc.setRootElement(rootEle);//设置文档 //若STU对象不为空 if(!Tools.isListEmpty(stu)) &#123; Element stuEle=docfactory.createElement(\"student\");//创建rooeEle下的子元素 Element NameEle=docfactory.createElement(\"name\");//创建stuEle下的子元素name NameEle.setText(stu.getName());//设置NameEle的文本值 Element SexEle=docfactory.createElement(\"sex\"); SexEle.setText(stu.getSex()); Element CodeEle=docfactory.createElement(\"code\"); CodeEle.setText(stu.getCode()); Element SpecialtyEle=docfactory.createElement(\"specialty\"); SpecialtyEle.setText(stu.getSpecialty()); /*将子元素添加到stuEle中*/ stuEle.add(NameEle); stuEle.add(CodeEle); stuEle.add(SexEle); stuEle.add(SpecialtyEle); /*将stuEle元素添加到根元素下*/ rootEle.add(stuEle); &#125; String classPath=Tools.getClassPath();//获取类路径 File xmlFile=new File(classPath+\"com/Xml/\"+fileName);//创建目标文件对象 Writer writer=null; try &#123; writer=new FileWriter(xmlFile);//创建Writer对象 XMLWriter xmlWriter=new XMLWriter(writer,OutputFormat.createPrettyPrint());//OutputFormat.createPrettyPrint()可以使XML文件形成一种规范 xmlWriter.write(doc);//保存为XML目标文件 writer.flush(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; try &#123; writer.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; /** * 在XML文档中添加学生对象 * @param fileName XML文件名称 * @param stuList 学生的对象 */ public static void AddStudent(String fileName,Student stu) &#123; String classPath=Tools.getClassPath();//获取类路径 File xmlFile=new File(classPath+\"com/Xml/\"+fileName);//基于文件路径创建文件对象 Reader reader=null; Writer writer=null; try &#123; reader=new FileReader(xmlFile);//基于XML文件建立文件流 SAXReader saxReader=new SAXReader();//建立SAX文件对象流 Document docReader=saxReader.read(reader);//读取XML文件 if(docReader!=null) &#123; Element rootEle=docReader.getRootElement();//获取根元素 Element stuEle=docfactory.createElement(\"student\");//创建rooeEle下的子元素 Element NameEle=docfactory.createElement(\"name\");//创建stuEle下的子元素name NameEle.setText(stu.getName());//设置NameEle的文本值 Element SexEle=docfactory.createElement(\"sex\"); SexEle.setText(stu.getSex()); Element CodeEle=docfactory.createElement(\"code\"); CodeEle.setText(stu.getCode()); Element SpecialtyEle=docfactory.createElement(\"specialty\"); SpecialtyEle.setText(stu.getSpecialty()); /*将子元素添加到stuEle中*/ stuEle.add(NameEle); stuEle.add(CodeEle); stuEle.add(SexEle); stuEle.add(SpecialtyEle); /*将stuEle元素添加到根元素下*/ rootEle.add(stuEle); &#125; writer=new FileWriter(xmlFile);//创建Writer对象 XMLWriter xmlWriter=new XMLWriter(writer,OutputFormat.createPrettyPrint());//OutputFormat.createPrettyPrint()可以使XML文件形成一种规范 xmlWriter.write(docReader);//保存为XML目标文件 //writer.flush(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; try &#123; writer.close(); reader.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; /** * 删除学生对象 * @param fileName XML文件名称 * @param stu 学生对象 */ public static void removeStudent(String fileName,String code) &#123; String classPath=Tools.getClassPath();//获取类路径 File xmlFile=new File(classPath+\"com/Xml/\"+fileName);//基于文件路径创建文件对象 Reader reader=null; Writer writer=null; try &#123; reader=new FileReader(xmlFile);//基于XML文件建立文件流 SAXReader saxReader=new SAXReader();//建立SAX文件对象流 Document docReader=saxReader.read(reader);//读取XML文件 if(docReader!=null) &#123; Element rootEle=docReader.getRootElement();//获取根元素 List&lt;Element&gt; elements=rootEle.elements(\"student\");//获取根元素下所有子元素 for(Element e:elements) &#123;//遍历根元素 String codeValue=e.element(\"code\").getText();//获取code属性值进行对比 if(code.equals(codeValue)) &#123; Element par=e.getParent(); par.remove(e); &#125; &#125; &#125; writer=new FileWriter(xmlFile);//创建Writer对象 XMLWriter xmlWriter=new XMLWriter(writer,OutputFormat.createPrettyPrint());//OutputFormat.createPrettyPrint()可以使XML文件形成一种规范 xmlWriter.write(docReader);//保存为XML目标文件 //writer.flush(); //writer.close(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; try &#123; reader.close(); writer.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; /** * 读取XMl文档内的学生对象信息 * @param fileName 文件路径 */ public static List&lt;Student&gt; PrintStudent(String fileName) &#123; List&lt;Student&gt; stuList=new ArrayList&lt;Student&gt;(); String classPath=Tools.getClassPath();//获取类路径 File xmlFile=new File(classPath+\"com/Xml/\"+fileName);//基于文件路径创建文件对象 Reader reader=null; try &#123; reader=new FileReader(xmlFile);//基于XML文件建立文件流 SAXReader saxReader=new SAXReader();//建立SAX文件对象流 Document docReader=saxReader.read(reader);//读取XML文件 if(docReader!=null) &#123; Element rootEle=docReader.getRootElement();//获取根元素 List&lt;Element&gt; eleList=rootEle.elements(\"student\");//获取所有根元素下的子元素 for(Element e:eleList) &#123; Student empObj=new Student(); String name=e.element(\"name\").getText();//获取元素name empObj.setName(name); String code=e.element(\"code\").getText();//获取元素code empObj.setCode(code); String sex=e.element(\"sex\").getText();//获取元素sex empObj.setSex(sex); String specialty=e.element(\"specialty\").getText();//获取元素specialty empObj.setSpecialty(specialty); stuList.add(empObj); &#125; &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; return stuList; &#125; /** * 修改学生信息 * @param fileName XML文档名 * @param stu 被修改的学生对象 */ public static void changeStudent(String fileName,Student stu) &#123; String classPath=Tools.getClassPath();//获取类路径 File xmlFile=new File(classPath+\"com/Xml/\"+fileName);//基于文件路径创建文件对象 Reader reader=null; Writer writer=null; try &#123; reader=new FileReader(xmlFile);//基于XML文件建立文件流 SAXReader saxReader=new SAXReader();//建立SAX文件对象流 Document docReader=saxReader.read(reader);//读取XML文件 if(docReader!=null) &#123; Element rootEle=docReader.getRootElement();//获取根元素 List&lt;Element&gt; elements=rootEle.elements(\"student\");//获取根元素下所有子元素 for(Element e:elements) &#123;//遍历根元素 String codeValue=e.element(\"code\").getText();//获取code属性值进行对比 if(stu.getCode().equals(codeValue)) &#123; Element nameEle=e.element(\"name\");//获取e元素下的子元素name nameEle.setText(stu.getName());//更改元素name的属性值 Element sexEle=e.element(\"sex\");//获取e元素下的子元素sex sexEle.setText(stu.getSex());//更改元素sex的属性值 Element specialtyEle=e.element(\"specialty\");//获取e元素下的子元素specialty specialtyEle.setText(stu.getSpecialty());//更改元素specialty的属性值 &#125; &#125; &#125; writer=new FileWriter(xmlFile);//创建Writer对象 XMLWriter xmlWriter=new XMLWriter(writer,OutputFormat.createPrettyPrint());//OutputFormat.createPrettyPrint()可以使XML文件形成一种规范 xmlWriter.write(docReader);//保存为XML目标文件 //writer.flush(); //writer.close(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; try &#123; reader.close(); writer.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; 实现可视化窗口以及各项操作的类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347package com.frame;import java.awt.BorderLayout;import java.awt.Container;import java.awt.Dimension;import java.awt.GridLayout;import java.awt.Toolkit;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import java.awt.event.MouseListener;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import java.net.URL;import java.util.ArrayList;import java.util.List;import java.util.Vector;import javax.swing.ImageIcon;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JMenu;import javax.swing.JMenuBar;import javax.swing.JMenuItem;import javax.swing.JOptionPane;import javax.swing.JPanel;import javax.swing.JPasswordField;import javax.swing.JScrollPane;import javax.swing.JSplitPane;import javax.swing.JTabbedPane;import javax.swing.JTable;import javax.swing.JTextField;import javax.swing.SwingConstants;import javax.swing.event.ChangeEvent;import javax.swing.event.ChangeListener;import javax.swing.table.DefaultTableModel;import com.entity.Student;import com.util.Dom4jManger;import com.util.Tools;/** * 界面类 * @author NEYMAR * */public class XmlFrame extends JFrame&#123; private JTabbedPane tabbedPane = new JTabbedPane();//创建一个选项卡 private JPanel addPanel=new JPanel(new GridLayout(6,1,5,5));//添加学生数据面板 private JPanel removePanel=new JPanel(new GridLayout(3,1,5,5));//删除学生数据面板 private JScrollPane printPanel;//浏览学生数据面板 private JPanel changePanel=new JPanel(new GridLayout(6,1,5,5));//修改学生数据面板 private JPanel pathPanel=new JPanel();//增加新的XML路径面板 /*添加学生数据面板组件*/ public JPanel addjp=new JPanel();//XML文档名称 public JPanel addjp1=new JPanel();//学生姓名 public JPanel addjp2=new JPanel();//学生学号 public JPanel addjp3=new JPanel();//学生性别 public JPanel addjp4=new JPanel();//学生专业 public JPanel addjp5=new JPanel();//按钮 public JLabel addjl=new JLabel(\"文档名称:\");//XML文档名称标签 public JLabel addjl1=new JLabel(\"学生姓名:\");//姓名标签 public JLabel addjl2=new JLabel(\"学生学号:\");//学号标签 public JLabel addjl3=new JLabel(\"学生性别:\");//性别标签 public JLabel addjl4=new JLabel(\"学生专业:\");//专业标签 public JTextField addj=new JTextField(); //XML文档名称的文本框 public JTextField addj1=new JTextField(); //学生姓名的文本框 public JTextField addj2=new JTextField(); //学生学号的文本框 public JTextField addj3=new JTextField(); //学生性别的文本框 public JTextField addj4=new JTextField(); //学生专业的文本框 public JButton addb1=new JButton(\"录入\");//定义一个录入按钮 /*新建XML文档面板组件*/ JPanel pathjp1=new JPanel(); public JLabel pathjl1=new JLabel(\"文档名称:\"); public JTextField pathj1=new JTextField(); public JButton pathb1=new JButton(\"新建\");//定义一个录入按钮 /*浏览学生信息面板组件*/ JTable table=null; Vector row,col; /*更改学生信息面板组件*/ public JPanel changejp=new JPanel();//XML文档名称 public JPanel changejp1=new JPanel();//学生姓名 public JPanel changejp2=new JPanel();//学生学号 public JPanel changejp3=new JPanel();//学生性别 public JPanel changejp4=new JPanel();//学生专业 public JPanel changejp5=new JPanel();//按钮面板 public JLabel changejl=new JLabel(\"文档名称:\");//XML文档名称标签 public JLabel changejl1=new JLabel(\"学生姓名:\");//姓名标签 public JLabel changejl2=new JLabel(\"学生学号:\");//学号标签 public JLabel changejl3=new JLabel(\"学生性别:\");//性别标签 public JLabel changejl4=new JLabel(\"学生专业:\");//专业标签 public JTextField changej=new JTextField(); //XML文档名文本框 public JTextField changej1=new JTextField(); //学生姓名的文本框 public JTextField changej2=new JTextField(); //学生学号的文本框 public JTextField changej3=new JTextField(); //学生性别的文本框 public JTextField changej4=new JTextField(); //学生专业的文本框 public JButton changeb1=new JButton(\"更改\");//定义一个录入按钮 /*删除学生信息面板组件*/ JPanel removejp1=new JPanel(); JPanel removejp2=new JPanel(); JPanel removejp3=new JPanel(); public JLabel removejl1=new JLabel(\"文档名称:\");//专业标签 public JTextField removej1=new JTextField();//学生性别的文本框 public JLabel removejl2=new JLabel(\"学生学号:\"); public JTextField removej2=new JTextField(); public JButton removeb1=new JButton(\"删除\");//定义一个录入按钮 /** * 构造函数 */ public XmlFrame() &#123; super(\"学生信息管理系统\"); setSize(600,400);//设置窗体大小 //获取屏幕的宽度和高度,并让窗口居中显示 double width=Toolkit.getDefaultToolkit().getScreenSize().getWidth(); double height=Toolkit.getDefaultToolkit().getScreenSize().getHeight(); setLocation((int)(width-this.getWidth())/2, (int)(height-this.getHeight())/2); setDefaultCloseOperation(EXIT_ON_CLOSE);//设置窗体关闭规则 Container con=getContentPane();//获取窗口容器 module();//初始化面板中的组件信息 buttonAction();//初始化面板中的点击事件 &#125; /** * 组件添加 */ public void module() &#123; /*标签面板*/ tabbedPane.setTabLayoutPolicy(JTabbedPane.SCROLL_TAB_LAYOUT);// 设置选项卡标签的布局方式 this.getContentPane().add(tabbedPane, BorderLayout.CENTER); /*添加学生数据面板信息*/ /*文本框长度*/ //addj.setBorder(null);//去掉文本框边线 addj.setColumns(18); addj1.setColumns(18); addj2.setColumns(18); addj3.setColumns(18); addj4.setColumns(18); /*添加组件*/ addjp.add(addjl); addjp.add(addj); addjp1.add(addjl1); addjp1.add(addj1); addjp2.add(addjl2); addjp2.add(addj2); addjp3.add(addjl3); addjp3.add(addj3); addjp4.add(addjl4); addjp4.add(addj4); addjp5.add(addb1); /*将学生信息面板添加到增加学生数据面板里*/ addPanel.add(addjp); addPanel.add(addjp1); addPanel.add(addjp2); addPanel.add(addjp3); addPanel.add(addjp4); addPanel.add(addjp5); /*新增XML路径面板信息*/ pathj1.setColumns(18); pathjp1.add(pathjl1); pathjp1.add(pathj1); pathjp1.add(pathb1); pathPanel.add(pathjp1); /*浏览学生信息表格*/ col=new Vector(); //设置列名 col.add(\"学号\"); col.add(\"姓名\"); col.add(\"性别\"); col.add(\"专业\"); row=new Vector(); List&lt;Student&gt; stulist=new ArrayList&lt;Student&gt;(); stulist=Dom4jManger.PrintStudent(\"stu.xml\"); for(Student k:stulist) &#123; Vector line=new Vector(); line.add(k.getCode()); line.add(k.getName()); line.add(k.getSex()); line.add(k.getSpecialty()); row.add(line); &#125; table=new JTable(row,col); printPanel=new JScrollPane(table); // 将标签组件添加到选项卡中 tabbedPane.add(\"建立新的xml文档\",pathPanel); tabbedPane.add(\"添加学生信息\",addPanel); tabbedPane.add(\"浏览学生信息\",printPanel); tabbedPane.add(\"更改学生信息\",changePanel); tabbedPane.add(\"删除学生信息\",removePanel); /*更改学生信息面板*/ changej.setColumns(18); changej1.setColumns(18); changej2.setColumns(18); changej3.setColumns(18); changej4.setColumns(18); changejp.add(changejl); changejp.add(changej); changejp1.add(changejl1); changejp1.add(changej1); changejp2.add(changejl2); changejp2.add(changej2); changejp3.add(changejl3); changejp3.add(changej3); changejp4.add(changejl4); changejp4.add(changej4); changejp5.add(changeb1); changePanel.add(changejp); changePanel.add(changejp2); changePanel.add(changejp1); changePanel.add(changejp3); changePanel.add(changejp4); changePanel.add(changejp5); /*删除学生信息面板*/ removej1.setColumns(18); removej2.setColumns(18); removejp1.add(removejl1); removejp1.add(removej1); removejp2.add(removejl2); removejp2.add(removej2); removejp3.add(removeb1); removePanel.add(removejp1); removePanel.add(removejp2); removePanel.add(removejp3); &#125; /** * 按钮点击事件 */ public void buttonAction() &#123; /*新建按钮点击事件*/ pathb1.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; // TODO Auto-generated method stub String pathName=pathj1.getText()+\".xml\"; if(!Tools.isXmlEmpty(pathName)) &#123; Student stu=new Student(\"初始化\",\"初始化\",\"初始化\",\"初始化\"); Dom4jManger dom=new Dom4jManger(pathName, stu); //创建XML文档 JOptionPane.showMessageDialog(null, pathName+\"创建成功\"); &#125; else &#123; JOptionPane.showMessageDialog(null, \"该文档已存在\"); &#125; &#125; &#125;); /*添加按钮点击事件*/ addb1.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent arg0) &#123; // TODO Auto-generated method stub String pathName=addj.getText()+\".xml\"; if(Tools.isXmlEmpty(pathName)) &#123; String name=addj1.getText(); String code=addj2.getText(); String sex=addj3.getText(); String spec=addj4.getText(); Student stu=new Student(code,name,sex,spec); Dom4jManger.AddStudent(pathName, stu); JOptionPane.showMessageDialog(null, \"学生\"+name+\"添加成功！\"); &#125; else &#123; JOptionPane.showMessageDialog(null, \"该文档不存在\"); &#125; &#125; &#125;); /*添加按钮点击事件*/ changeb1.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; // TODO Auto-generated method stub String pathName=changej.getText()+\".xml\"; if(Tools.isXmlEmpty(pathName)) &#123; String name=changej1.getText(); String code=changej2.getText(); String sex=changej3.getText(); String spec=changej4.getText(); Student stu=new Student(code,name,sex,spec); Dom4jManger.changeStudent(pathName, stu);; JOptionPane.showMessageDialog(null, \"更改成功！\"); &#125; else &#123; JOptionPane.showMessageDialog(null, \"该文档不存在\"); &#125; &#125; &#125;); /*删除按钮点击事件*/ removeb1.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; // TODO Auto-generated method stub String pathName=removej1.getText()+\".xml\"; if(Tools.isXmlEmpty(pathName)) &#123; String code=removej2.getText(); Dom4jManger.removeStudent(pathName, code); JOptionPane.showMessageDialog(null, \"删除成功！\"); &#125; else &#123; JOptionPane.showMessageDialog(null, \"该文档不存在\"); &#125; &#125; &#125;); /*表格双击事件*/ table.addMouseListener(new MouseAdapter() &#123; public void mouseClicked(MouseEvent e) &#123;//当鼠标双击时响应 // TODO Auto-generated method stub int row=table.getSelectedRow();//获取行 int column=table.getSelectedColumn();//获取列 int r=row+1; int c=column+1; Object value=table.getValueAt(row,column); String info=r+\"行\"+c+\"列\"; JOptionPane.showMessageDialog(null, info); &#125; &#125;); &#125; public static void main(String[] args) &#123; XmlFrame xm=new XmlFrame(); xm.setVisible(true); &#125;&#125; 程序运行后：进行新建功能测试： 找到工程目录查看：成功创建！用记事本打开后：添加学生单位：之后小编又添加了几个学生对象，查看原XML文档：添加成功，之后浏览学生信息：读取XML文档信息成功，之后还可以进行删除和修改学生信息的操作，有兴趣的小伙伴可以自己操作一下哦！谢谢！","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"简易计算器","slug":"JavaCalculator","date":"2020-02-10T16:00:00.000Z","updated":"2020-06-14T09:44:57.785Z","comments":true,"path":"2020/02/11/JavaCalculator/","link":"","permalink":"http://yoursite.com/2020/02/11/JavaCalculator/","excerpt":"","text":"基于swing组件进行开发：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391package calculator_1;import java.awt.BorderLayout;import java.awt.Color;import java.awt.Container;import java.awt.GridLayout;import java.awt.LayoutManager;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JOptionPane;import javax.swing.JPanel;import javax.swing.JTextField;import java.math.*;public class Count_1 extends JFrame&#123; int i; /*判断运算数据类型 * i=1 加法 * i=2 减法 * i=3 乘法 * i=4 除法 * i=5 取余 * i=6 求根 */ double a,b;//储存两个计算数的值 private String[] labels= &#123; \"C\",\"/\",\"*\",\"X\", \"7\",\"8\",\"9\",\"-\", \"4\",\"5\",\"6\",\"+\", \"1\",\"2\",\"3\",\".\", \"%\",\"0\",\"q\",\"=\" &#125;;//按钮信息 private JTextField jt=new JTextField(20); //输出一个文本框 JButton c[]=new JButton[20];//创建按钮 Count_1()&#123; super(\"计算器\");//填写标题名字 setBounds(650,300,230,230);//设置窗体大小 setDefaultCloseOperation(EXIT_ON_CLOSE); //设置关闭规则，窗体关闭时结束程序运行 Container con=getContentPane();//获取窗体容器 final JPanel p1=new JPanel();//设置显示面板 getContentPane().add(p1,BorderLayout.NORTH); //顶层显示 //result.setHorizontalAlignment(SwingConstants.RIGHT); //设置文本的水平对齐方式 jt.setEditable(false); //只能显示，不能编辑 jt.setColumns(18); jt.setBorder(null);//去掉文本框边线 jt.setHorizontalAlignment(JTextField.RIGHT); //文本框信息从右边显示 p1.add(jt);//将显示器添加到面板p1中 JPanel p2=new JPanel(new GridLayout(5,4));//设置按钮面板，并设置布局为5行四列 getContentPane().add(p2,BorderLayout.CENTER);//设置按键面板显示在窗体底部 for(int j=0;j&lt;20;j++) &#123; c[j]=new JButton(labels[j]);//添加按钮信息 p2.add(c[j]);//添加按钮 &#125; setVisible(true);//设置窗体可见 &#125; public void Button_action() &#123; c[19].setBackground(Color.pink);//改变按钮颜色 c[0].addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; // TODO Auto-generated method stub jt.setText(\"\");//清空文本框信息 &#125; &#125;); c[1].addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; // TODO Auto-generated method stub i=4; if(\"\".equals(jt.getText())) //判断文本框是否为空 JOptionPane.showMessageDialog(null, \"请先输入除数\"); //若为空，则弹出提示框 else &#123; a=Double.parseDouble(jt.getText());//数据转换，将除数的值赋给a jt.setText(jt.getText()+((JButton)e.getSource()).getText()); //文本框显示除法符号以及原有符号 &#125; &#125; &#125;); c[2].addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; // TODO Auto-generated method stub i=3; if(\"\".equals(jt.getText())) //判断文本框是否为空 JOptionPane.showMessageDialog(null, \"请先输入乘数\"); //若为空，则弹出提示框 else &#123; a=Double.parseDouble(jt.getText());//数据转换，将乘数的值赋给a jt.setText(jt.getText()+((JButton)e.getSource()).getText()); //文本框显示除法符号以及原有符号 &#125; &#125; &#125;); c[3].addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; // TODO Auto-generated method stub if(!\"\".equals(jt.getText()))//若文本框不为空，则可执行撤销操作 &#123; String wr=jt.getText();//得到文本框内数据 jt.setText(wr.substring(0,wr.length()-1)); &#125; &#125; &#125;); c[4].addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; // TODO Auto-generated method stub if(!\"\".equals(jt.getText())) jt.setText(jt.getText()+((JButton)e.getSource()).getText()); else jt.setText(((JButton)e.getSource()).getText()); &#125; &#125;); c[5].addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; // TODO Auto-generated method stub if(!\"\".equals(jt.getText())) jt.setText(jt.getText()+((JButton)e.getSource()).getText()); else jt.setText(((JButton)e.getSource()).getText()); &#125; &#125;); c[6].addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; // TODO Auto-generated method stub if(!\"\".equals(jt.getText())) jt.setText(jt.getText()+((JButton)e.getSource()).getText()); else jt.setText(((JButton)e.getSource()).getText()); &#125; &#125;); c[7].addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; // TODO Auto-generated method stub i=2; if(\"\".equals(jt.getText())) //判断文本框是否为空 JOptionPane.showMessageDialog(null, \"请先输入减数\"); //若为空，则弹出提示框 else &#123; a=Double.parseDouble(jt.getText()); jt.setText(jt.getText()+((JButton)e.getSource()).getText());//文本框显示减法符号 &#125; &#125; &#125;); c[8].addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; // TODO Auto-generated method stub if(!\"\".equals(jt.getText())) jt.setText(jt.getText()+((JButton)e.getSource()).getText()); else jt.setText(((JButton)e.getSource()).getText()); &#125; &#125;); c[9].addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; // TODO Auto-generated method stub if(!\"\".equals(jt.getText())) jt.setText(jt.getText()+((JButton)e.getSource()).getText()); else jt.setText(((JButton)e.getSource()).getText()); &#125; &#125;); c[10].addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; // TODO Auto-generated method stub if(!\"\".equals(jt.getText())) jt.setText(jt.getText()+((JButton)e.getSource()).getText()); else jt.setText(((JButton)e.getSource()).getText()); &#125; &#125;); c[11].addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; // TODO Auto-generated method stub i=1; if(\"\".equals(jt.getText())) //判断文本框是否为空 JOptionPane.showMessageDialog(null, \"请先输入加数\"); //若为空，则弹出提示框 else &#123; a=Double.parseDouble(jt.getText()); jt.setText(jt.getText()+((JButton)e.getSource()).getText());//文本框显示加法符号 &#125; &#125; &#125;); c[12].addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; // TODO Auto-generated method stub if(!\"\".equals(jt.getText())) jt.setText(jt.getText()+((JButton)e.getSource()).getText()); else jt.setText(((JButton)e.getSource()).getText()); &#125; &#125;); c[13].addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; // TODO Auto-generated method stub if(!\"\".equals(jt.getText())) jt.setText(jt.getText()+((JButton)e.getSource()).getText()); else jt.setText(((JButton)e.getSource()).getText()); &#125; &#125;); c[14].addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; // TODO Auto-generated method stub if(!\"\".equals(jt.getText())) jt.setText(jt.getText()+((JButton)e.getSource()).getText()); else jt.setText(((JButton)e.getSource()).getText()); &#125; &#125;); c[15].addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; // TODO Auto-generated method stub if(!\"\".equals(jt.getText())) jt.setText(jt.getText()+((JButton)e.getSource()).getText()); else jt.setText(((JButton)e.getSource()).getText()); &#125; &#125;); c[16].addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; // TODO Auto-generated method stub i=5; if(\"\".equals(jt.getText())) //判断文本框是否为空 JOptionPane.showMessageDialog(null, \"请先输入取余数\"); //若为空，则弹出提示框 else &#123; a=Double.parseDouble(jt.getText()); jt.setText(jt.getText()+((JButton)e.getSource()).getText());//文本框显示取余数符号 &#125; &#125; &#125;); c[17].addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; // TODO Auto-generated method stub if(!\"\".equals(jt.getText())) jt.setText(jt.getText()+((JButton)e.getSource()).getText()); else jt.setText(((JButton)e.getSource()).getText()); &#125; &#125;); c[18].addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; // TODO Auto-generated method stub if(!\"\".equals(jt.getText())) JOptionPane.showMessageDialog(null, \"请先输入开根号\"); else &#123; i=6; jt.setText(((JButton)e.getSource()).getText());//在文本框显示按钮的信息 &#125; &#125; &#125;); c[19].addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; // TODO Auto-generated method stub if(i==1) &#123; String tp=jt.getText(); int m=tp.indexOf('+'); String tp1=tp.substring(m+1); b=Double.parseDouble(tp1); double k=a+b; //保留小数点后6位数 String tp3=String.format(\"%.6f\",k); jt.setText(tp3); &#125; else if(i==2) &#123; String tp=jt.getText(); int m=tp.indexOf('-'); String tp1=tp.substring(m+1); b=Double.parseDouble(tp1); double k=a-b; String tp3=String.format(\"%.6f\",k); jt.setText(tp3); &#125; else if(i==3) &#123; String tp=jt.getText(); int m=tp.indexOf('*'); String tp1=tp.substring(m+1); b=Double.parseDouble(tp1); double k=a*b; String tp3=String.format(\"%.6f\",k); jt.setText(tp3); &#125; else if(i==4) &#123; String tp=jt.getText(); int m=tp.indexOf('/'); String tp1=tp.substring(m+1); b=Double.parseDouble(tp1); double k=a/b; String tp3=String.format(\"%.6f\",k); jt.setText(tp3); &#125; else if(i==5) &#123; String tp=jt.getText(); int m=tp.indexOf('%'); String tp1=tp.substring(m+1); b=Double.parseDouble(tp1); double k=a%b; String tp3=String.format(\"%.6f\",k); jt.setText(tp3); &#125; else if(i==6) &#123; String tp=jt.getText(); int m=tp.indexOf('q'); String tp1=tp.substring(m+1); b=Double.parseDouble(tp1); if(b&gt;=0) &#123; double k=Math.sqrt(b); String tp3=String.format(\"%.6f\",k); jt.setText(tp3); &#125; else JOptionPane.showMessageDialog(null, \"开根数必须为正数\"); &#125; &#125; &#125;); &#125; /*main函数*/ public static void main(String[] args) &#123; // TODO Auto-generated method stub Count_1 c=new Count_1();//定义一个 c.Button_action(); &#125;&#125; 运行结果：","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]}],"categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"},{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]}